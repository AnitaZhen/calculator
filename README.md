# Anita Zhen 
<b>Expression Evaluator and Calculator GUI</b>

<b><u>Overview: </u></b> The purpose of this assignment is to practice object oriented design to create two programs:
1. An object that evaluates mathematical expressions
2. A GUI around the artifact from (1)

<b><u>Introduction: </u></b>

  In this project, we are to implement a calculator class where it lets the user to calculate any math equation. The purpose of this assignment is to review the basics of Java and understand how we push to the stack and pop off the stack. We are to understand the basics of object-oriented design in a mathematical expression and a GUI interface. A mathematical expression includes a series of PEMDAS. In this first assignment, I was given a project where it had an almost finished code in each file, Evaluator.java, EvaluatorTester.Java, EvaluatorIU.java, operator.java, and operand.java class. We are to use the knowledge of stack to push and pop the values. 

<b><u>Result: </u></b>
<p>     
   In the EvaluatorTester class it will produce an expression and print out its value from the hardcopy. When I printed the file, I got 2+3-5*((2-3)*2-5*2+3*(2-3- 5-5*6)+4/2)*2-9 = 1176. In the EvaluatorUI class, it will pop open a calculator and we can press its button to calculate its expression. For example, if we press 1+2+3-3, it will equal 3. Then if we want to reset the expression, we press CE and C to erase the last digit. The problem in mine is that when I press both C and or CE, it erases the whole expression. In addition, if we want to start with a negative value in the expression, it will not work. I think it is because of the rule of PEMDAS , where we have to follow the order of operations, so the code believes it has to start with a parenthesis or an add sign.</p>
 <p>
   In the Evaluator class, we are to implement a single public method that takes a single String parameter that represent a math expression, parses, and evaluates the expression, and returns the integer result. In this class, the evaluator processes the tokens in the expression string using the two stacks given; operator and operand. The two stacks given are where the operand and or operator would scan the token and the object of that class is created from the token and then pushed to the operand Stack. Then if the operator token is scanned, and the operator Stack is not empty, and we see that the operator given in the expression has higher priority of the Operator at the top of the stack, then the Operator object is created from the token, and pushed to the operator Stack. Next, if the token is faced with open left parenthesis (, this mean the Operator object is created from the token, and pushed to the operator Stack. On the other hand, ) is the process Operators until the corresponding ( is encountered then we would pop the ( operator. We as the user will believe that when we enter an expression into the calculator, it will start with ( operator and resets itself. However, in my result in the EvaluatorUI.java, whenever we get the result the key sticks to the equal sign. So for example 1+2=3, instead of resetting itself to calculate another expression it will keep the 3 and your other new numbers. To reset the calculator, we would have to press CE.</p>
      <p> 
  In my code, we first have two separate stacks: operand and operator, where it holds an operator class. This will get the equation and store it inside the tokenizer class. The string takes the equation and breaks it off the two class files. When it comes into contact with the code, it will look through the expression and pass in its values. In the value that it stores, tokens, it will check if the number we entered is an integer or not. If not, it will return a statement saying the number or expression is invalid. When it is done checking, it will push to the operand stack. We have a while loop because we have a series of tokens so it will go through each loop and check its expression and number. Then it will go push to the operator stack and see if the expression is created in the stack. We have an empty stack first when we entered the code because the system will believe we are starting from scratch and we are creating an operator stack. Then in the end of the class file, we will separate the stack and pop and evaluate the equation. Then we pop the operator and push the operand and calculate its value on the operand stack.</p>
     <p> In the Operator class, we are to pop the operand Stack twice, then pop the operator Stack, then execute the Operator with the two Operands, and lastly, push the result onto the Operand Stack. In this file, I implemented a hashmap where I created different operators classes to support the object. The hashmap is where we store the operator token as a key, and its properties as value. This operator class will store the priority and functionality of an operator, for example a multiply has a higher priority than a add since it doubles more. When it execute, it will extend its operator, implement and execute. For each operator I extended and add, I created a separate class package for that operator. These operators will perform different functions as it will believe it’s the same name and return the new constructor and push it to the operator stack. In each operator class I implemented, I included their priority, as 0 has the least priority, while a 4 has the most priority. For example, a carrot has the highest priority because when we multiply to a certain value, it will double its amount having a greater result then a multiply or an add symbol. In each class operator, I have hash operator as zero priority, add and subtract operator as priority two and multiply and divide as third priority.</p>
     <p> In the operand class, we will store its token and it will have its value. The integer provided in the function will compose a number and convert to number, which is a function overloading.</p>
     <p> In the evaluatorUI, the action performed method is where I created 20 if else statements. This will let the system go through each statement and choose its number. I thought about creating a switch statement because it can go through each statement and check its number. If it’s the wrong statement then it will go to the next statement, however the string “button” is a constant word, which will cause an error in the code. This is why I created 20 if statements going through each if statement. This is to let the compiler listen to what you entered in the function in what you enter and record its values. It is going to enter what you called.</p>
     <p>This assignment also gave extra credit if we implemented a # and ! operator. However, I just implemented an # key but I do not think it does anything in the calculator since it has zero priority. I did not implement an ! operator. These key allows us to remove some comparison from the loop, at the cost of one or two additional operations outside of the token processing loop. </p>
    <p> Then finally, I attached in the documentation my hierarchy class showing how each class connects with other method showing and proving how an expression prints its value with one another.</p>

<b>Command Line:</b>
git clone https://github.com/AnitaZhen/calculator.git
<p>ls</p>
<p>cd (to correct libary and or branch) </p>
<p> git add . </p>
<p> git commit -m "Some message" </p>
<p> git push -u origin master </p>

<b>Conclusion:</b>
In conclusion, in this project I reviewed the java stack functions; pop, push and call to the stack. Some challenges I faced through the project was when I created an add function. I forgot we had to create another class file if we create an add function instead of just extending it in the operand class. In addition, I had trouble with turning a string to int. I know that is invalid, which is why I changed the data type to an integer because what we entered in the calculator is a number. In the future I will know that when the calculator finish with the expression, it will pop its operator and print its result.
